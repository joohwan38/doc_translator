<!DOCTYPE html>
<html lang="ko"> <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document Translator</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: #f8f9fa;
            color: #333;
            line-height: 1.6;
            font-size: 14px;
        }
        
        .container {
            max-width: 1000px;
            margin: 0 auto;
            padding: 15px;
        }
        
        header {
            background-color: #fff;
            padding: 10px 15px;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            margin-bottom: 15px;
        }

        .header-top-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
        }

        .logo {
            height: 36px;
            margin-right: 15px;
        }
        
        h1 {
            color: #2c3e50;
            font-size: 1.4em;
            text-align: center;
            flex-grow: 1;
        }

        .header-controls {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            min-width: 150px; /* Ensure minimum width for controls */
        }

        #ui-language {
            width: 130px;
            padding: 6px;
            font-size: 0.85em;
            border-radius: 4px;
        }
        
        #server-status {
            font-size: 0.8em;
            margin-top: 3px;
            text-align: right;
        }
        
        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }
        
        .panel {
            background-color: #fff;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        
        .full-width {
            grid-column: span 2;
        }
        
        .status-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 5px;
        }
        
        .status-online { background-color: #27ae60; }
        .status-offline { background-color: #e74c3c; }
        
        .form-group {
            margin-bottom: 10px;
        }

        .language-selection-area {
            display: flex;
            justify-content: space-between;
            align-items: flex-start; 
            gap: 10px;
        }

        .language-column {
            flex: 1;
            display: flex;
            flex-direction: column;
        }
        
        .language-column label {
            margin-bottom: 4px;
            font-weight: bold;
        }

        .language-swap-column {
            display: flex;
            align-items: center;
            padding-top: calc((0.9em * 1.6) + 3px); 
        }

        #swap-lang-btn {
            padding: 8px 10px;
            min-width: auto;
            width: auto;
            line-height: 1;
            font-size: 1.1em;
        }
        
        label {
            display: block;
            margin-bottom: 3px;
            font-weight: bold;
            color: #555;
            font-size: 0.9em;
        }
        
        input[type="file"] {
            display: none; 
        }

        select, button, input[type="range"], input[type="checkbox"]+label {
            width: 100%;
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 0.9em;
        }
        input[type="checkbox"] {
            width: auto;
            margin-right: 5px;
        }

        button {
            background-color: #007bff;
            color: white;
            border: none;
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.2s;
        }
        
        button:hover {
            background-color: #0056b3;
        }
        
        button:disabled {
            background-color: #bdc3c7;
            cursor: not-allowed;
        }

        button.stop-button {
            background-color: #dc3545;
        }
        button.stop-button:hover {
            background-color: #c82333;
        }

        button.download-button {
            background-color: #28a745;
        }
        button.download-button:hover {
            background-color: #218838;
        }


        .action-button { 
            background-color: #6c757d;
            font-size: 0.85em;
            padding: 6px 10px;
            width: auto;
            margin-right: 5px;
        }
        .action-button:last-child {
             margin-right: 0;
        }
        .action-button:hover {
            background-color: #5a6268;
        }
        
        .file-upload-label {
            display: block;
            padding: 10px;
            background-color: #ecf0f1;
            border: 2px dashed #bdc3c7;
            border-radius: 5px;
            text-align: center;
            transition: all 0.3s;
            cursor: pointer;
        }
        
        .file-upload-label.dragover-active { 
            background-color: #d5dbdb;
            border-color: #95a5a6;
        }
        
        .progress-bar {
            height: 25px;
            background-color: #e9ecef;
            border-radius: 12px;
            overflow: hidden;
            margin: 15px 0;
        }
        
        .progress-fill {
            height: 100%;
            background-color: #007bff;
            width: 0%;
            transition: width 0.3s ease, background-color 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 0.9em;
        }
        
        .info-box {
            background-color: #e9ecef;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
            font-size: 0.85em;
        }
        
        .log-box {
            background-color: #212529;
            color: #f8f9fa;
            padding: 10px;
            border-radius: 4px;
            height: 220px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.8em;
            line-height: 1.4;
        }
        .log-entry-error { color: #e74c3c; }
        .log-entry-success { color: #27ae60; }
        .log-entry-info { color: #f8f9fa; } 
        .log-entry-warning { color: #f39c12; }


        .history-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
            font-size: 0.85em;
        }
        .history-table th, .history-table td {
            padding: 8px;
            text-align: left;
            border-bottom: 1px solid #dee2e6;
        }
        .history-table th {
            background-color: #f1f3f5;
            font-weight: bold;
        }
        
        .advanced-settings {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #dee2e6;
        }

        .advanced-options-horizontal {
            display: flex;
            gap: 15px;
        }
         .advanced-options-horizontal .form-group {
            flex: 1;
        }
        
        .checkbox-group {
            display: flex;
            align-items: center;
        }
        .checkbox-group label {
            font-weight: normal;
            margin-bottom: 0;
        }
        
        .tabs {
            display: flex;
            justify-content: space-between; 
            align-items: center;
            border-bottom: 2px solid #dee2e6;
            margin-bottom: 10px;
        }
        .tab-group {
            display: flex; 
        }
        .tab-buttons { 
            display: flex;
        }
        
        .tab {
            padding: 8px 15px;
            cursor: pointer;
            border-bottom: 3px solid transparent;
            transition: all 0.3s;
            font-size: 0.9em;
        }
        
        .tab.active {
            border-bottom-color: #007bff;
            color: #007bff;
            font-weight: bold;
        }
        
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }

        /* Custom Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            display: flex; /* Changed from none to flex for centering */
            justify-content: center;
            align-items: center;
            z-index: 1000;
            /* display: none; /* Initially hidden */
        }

        .modal-content {
            background-color: #fff;
            padding: 25px;
            border-radius: 8px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            width: 90%;
            max-width: 450px;
            text-align: center;
        }

        .modal-content h3 {
            margin-top: 0;
            margin-bottom: 15px;
            color: #333;
        }

        .modal-content p {
            margin-bottom: 20px;
            color: #555;
            font-size: 0.95em;
            line-height: 1.6;
        }

        .modal-actions button {
            padding: 10px 20px;
            margin: 0 10px;
            border-radius: 5px;
            font-size: 0.9em;
            cursor: pointer;
            min-width: 100px;
        }

        #modal-confirm-btn { /* Generic confirm, can be overridden by more specific i18n keys */
            background-color: #007bff;
            color: white;
            border: 1px solid #007bff;
        }
        #modal-confirm-btn:hover {
            background-color: #0056b3;
        }

        #modal-cancel-btn { /* Generic cancel */
            background-color: #6c757d;
            color: white;
            border: 1px solid #6c757d;
        }
        #modal-cancel-btn:hover {
            background-color: #5a6268;
        }
        
        @media (max-width: 768px) {
            .main-content { grid-template-columns: 1fr; }
            .header-top-row { flex-direction: column; align-items: flex-start; }
            h1 { text-align: left; margin-top: 5px; margin-bottom: 5px; }
            .header-controls { width: 100%; flex-direction: row; justify-content: space-between; align-items: center; }
            #ui-language { width: auto; }
            .language-selection-area { flex-direction: column; gap: 5px; }
            .language-swap-column { padding-top: 5px; align-self: center; }
            .advanced-options-horizontal { flex-direction: column; gap: 0;}
            .tabs { flex-direction: column; align-items: stretch; }
            .tab-group { margin-bottom: 5px; }
            .tab-buttons { justify-content: flex-end; }
            .modal-content { padding: 20px; max-width: 90%;}
            .modal-actions button { margin: 5px; min-width: 80px; }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <div class="header-top-row">
                <img src="/static/LINEstudio2.png" alt="Logo" class="logo">
                <h1 id="app-title" data-i18n="app_title">Document Translator</h1>
                <div class="header-controls">
                    <select id="ui-language"> </select>
                    <div id="server-status">
                        <span class="status-indicator status-offline"></span>
                        <span>Ollama <span id="status-label" data-i18n="status_label">Status</span>: <span id="ollama-status" data-i18n="status_checking">Checking...</span></span>
                    </div>
                    <div id="ollama-management-area" style="font-size: 0.8em; margin-top: 5px; text-align: right;"></div>
                    <div id="model-installation-status" style="font-size: 0.8em; margin-top: 5px; text-align: right; display: none;">
                        <span id="model-install-message"></span>
                        <div id="model-install-progress-bar" style="background-color: #e0e0e0; border-radius: 3px; margin-top: 2px; display: none;">
                            <div id="model-install-progress-fill" style="width: 0%; background-color: #4caf50; height: 10px; border-radius: 3px; text-align: center; line-height: 10px; font-size: 8px; color: white;">0%</div>
                        </div>
                    </div>
                 </div>
            </div>
        </header>
        
        <div class="main-content">
            <div class="panel"> <h2 data-i18n="file_select_title">File Selection</h2>
                <div class="form-group">
                    <div class="file-upload">
                        <input type="file" id="file-input" accept=".pptx,.xlsx"> <label for="file-input" class="file-upload-label" data-i18n="file_upload_label">
                            Select or drag and drop a PowerPoint file here
                        </label>
                    </div>
                </div>
                <div id="file-info" class="info-box" style="display: none;">
                    <h3 data-i18n="file_info_title">File Information</h3>
                    <div class="info-item"><span data-i18n="file_name_label">Filename:</span><span id="file-name">-</span></div>
                    <div class="info-item"><span data-i18n="slide_count_label">Slides:</span><span id="slide-count">-</span></div>
                    <div class="info-item"><span data-i18n="text_count_label">Text (Chars):</span><span id="text-count">-</span></div>
                    <div class="info-item"><span data-i18n="image_count_label">Images:</span><span id="image-count">-</span></div>
                    <div class="info-item"><span data-i18n="chart_count_label">Charts:</span><span id="chart-count">-</span></div>
                </div>
            </div>
            
            <div class="panel"> <h2 data-i18n="translation_options_title">Translation Options</h2>
                <div class="form-group language-selection-area">
                    <div class="language-column">
                        <label for="src-lang" data-i18n="source_language_label_short">Source Language</label>
                        <select id="src-lang"></select>
                    </div>
                    <div class="language-swap-column">
                        <button id="swap-lang-btn" title="Swap Languages" data-i18n-tooltip="swap_lang_button_tooltip">↔</button>
                    </div>
                    <div class="language-column">
                        <label for="tgt-lang" data-i18n="target_language_label_short">Target Language</label>
                        <select id="tgt-lang"></select>
                    </div>
                </div>
                
                <div class="form-group">
                    <label for="model" data-i18n="translation_model_label">Translation Model</label>
                    <select id="model"><option value="" data-i18n="model_loading">Loading models...</option></select>
                </div>
                
                <div class="advanced-settings">
                    <h3 data-i18n="advanced_settings_title">Advanced Settings</h3>
                    <div class="advanced-options-horizontal">
                        <div class="form-group checkbox-group">
                            <input type="checkbox" id="image-translation" checked>
                            <label for="image-translation" data-i18n="image_translation_checkbox">Translate text in images (OCR)</label>
                        </div>
                        <div class="form-group checkbox-group">
                            <input type="checkbox" id="ocr-gpu">
                            <label for="ocr-gpu" data-i18n="ocr_gpu_checkbox">Use OCR GPU</label>
                        </div>
                    </div>
                    <div class="form-group">
                        <label data-i18n="ocr_temp_label">OCR Temperature (0.1 - 1.0) <span style="font-weight:normal; color: #555;" data-i18n="ocr_temp_recommended">(Recommended: 0.4)</span></label>
                        <div class="slider-group">
                            <input type="range" id="ocr-temp" class="slider" min="0.1" max="1.0" step="0.1" value="0.4">
                            <span class="slider-value" id="ocr-temp-value">0.4</span>
                        </div>
                    </div>
                </div>
                <div class="translation-actions-container" style="display: flex; flex-direction: row; gap: 10px; margin-top: 10px;">
                    <button id="start-translate-btn" data-i18n="start_translation_button" style="flex-grow: 1;">번역 시작</button>
                    <button id="action-btn" style="flex-grow: 1; display: none;"></button>
                </div>
            </div> <div class="panel full-width" id="progress-panel" style="display: none;">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <h2 data-i18n="translation_progress_title">Translation Progress</h2>
                </div>
                <div class="progress-bar"><div class="progress-fill" id="progress-fill">0%</div></div>
                <div id="progress-status" data-i18n="status_preparing">Preparing...</div>
                <div id="current-task" style="color: #666; font-size: 0.9em; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;"></div>
            </div>
            
            <div class="panel full-width">
                <div class="tabs">
                    <div class="tab-group">
                        <span class="tab active" data-tab="log" data-i18n="execution_log_tab">Execution Log</span>
                        <span class="tab" data-tab="history" data-i18n="translation_history_tab">Translation History</span>
                    </div>
                    <div class="tab-buttons">
                        </div>
                </div>
                
                <div id="log-tab" class="tab-content active">
                    <div class="log-box" id="log-box"><span data-i18n="app_started_log">Application started...</span></div>
                </div>
                
                <div id="history-tab" class="tab-content">
                    <table class="history-table">
                        <thead><tr>
                            <th data-i18n="history_col_filename">Filename</th> <th data-i18n="history_col_source">Source</th>
                            <th data-i18n="history_col_target">Target</th> <th data-i18n="history_col_model">Model</th>
                            <th data-i18n="history_col_status">Status</th> <th data-i18n="history_col_time">Time</th>
                        </tr></thead>
                        <tbody id="history-body"></tbody>
                    </table>
                </div>
                <button id="openLogFolderBtn" style="margin-top: 10px;">Open Log Folder</button> </div>
        </div> </div> <div id="custom-modal" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <h3 id="modal-title" data-i18n="modal_title_default">Confirmation</h3>
            <p id="modal-message" data-i18n="modal_message_default">Are you sure?</p>
            <div class="modal-actions">
                <button id="modal-confirm-btn" data-i18n="modal_button_confirm">Confirm</button>
                <button id="modal-cancel-btn" data-i18n="modal_button_cancel">Cancel</button>
                </div>
        </div>
    </div>
    
    <script>
        // Global variables
        let currentFileObject = null;
        let currentServerFilePath = null;
        let currentOriginalFilePath = null; // 원본 파일의 전체 경로 저장용
        let currentTaskTempOutputPath = null; // 번역된 임시 파일의 전체 경로 저장용
        let currentTranslationTaskId = null;
        let progressEventSource = null;
        let modelPullEventSource = null;
        let currentUILocale = 'ko';
        let i18nResources = {};
        let isModelInstallationInProgress = false;
        let defaultOllamaModel = "gemma3n:e2b"; // 또는 config.py에서 가져온 값
        let translatedFileAvailableButNotDownloaded = false;
        let lastDownloadedTaskId = null; // 마지막으로 다운로드 시작한 작업 ID
        // let lastDownloadedFilePath = null; // (두 번째 이슈 해결 시 사용될 변수)

        // Application States for the main button
        const APP_STATE = {
            IDLE: 'idle',
            UPLOADING: 'uploading',
            ANALYZING: 'analyzing',
            TRANSLATING: 'translating',
            STOPPING: 'stopping',
            COMPLETED_SUCCESS: 'completed_success',
            COMPLETED_ERROR: 'completed_error',
            DOWNLOADING_MODEL: 'downloading_model',
            AWAITING_DOWNLOAD_CONFIRMATION: 'awaiting_download_confirmation',
            DOWNLOAD_COMPLETED_CAN_OPEN_FOLDER: 'download_completed_can_open_folder'
        };
        let currentAppState = APP_STATE.IDLE;

        // Modal callback storage
        let modalConfirmCallback = null;
        let modalCancelCallback = null;
        let modalThirdOptionCallback = null;


        // DOM Element References
        const domElements = {
            fileInput: document.getElementById('file-input'),
            fileUploadLabel: document.getElementById('file-input').labels[0] || document.querySelector('.file-upload-label'),
            fileInfoBox: document.getElementById('file-info'),
            fileNameDisplay: document.getElementById('file-name'),
            ollamaManagementArea: document.getElementById('ollama-management-area'),
            modelInstallationStatus: document.getElementById('model-installation-status'),
            modelInstallMessage: document.getElementById('model-install-message'),
            modelInstallProgressBar: document.getElementById('model-install-progress-bar'),
            modelInstallProgressFill: document.getElementById('model-install-progress-fill'),
            slideCountDisplay: document.getElementById('slide-count'),
            textCountDisplay: document.getElementById('text-count'),
            imageCountDisplay: document.getElementById('image-count'),
            chartCountDisplay: document.getElementById('chart-count'),
            sourceLangSelect: document.getElementById('src-lang'),
            targetLangSelect: document.getElementById('tgt-lang'),
            swapLangButton: document.getElementById('swap-lang-btn'),
            modelSelect: document.getElementById('model'),
            startTranslateButton: document.getElementById('start-translate-btn'),
            actionButton: document.getElementById('action-btn'),
            progressPanel: document.getElementById('progress-panel'),
            progressFill: document.getElementById('progress-fill'),
            progressStatusDisplay: document.getElementById('progress-status'),
            currentTaskDisplay: document.getElementById('current-task'),
            logBox: document.getElementById('log-box'),
            ocrTemperatureSlider: document.getElementById('ocr-temp'),
            ocrTemperatureValueDisplay: document.getElementById('ocr-temp-value'),
            uiLanguageSelect: document.getElementById('ui-language'),
            ollamaStatusIndicator: document.querySelector('#server-status .status-indicator'),
            ollamaStatusText: document.getElementById('ollama-status'),
            ollamaStatusLabel: document.getElementById('status-label'),
            tabs: document.querySelectorAll('.tabs .tab-group .tab'),
            tabContents: document.querySelectorAll('.panel.full-width > .tab-content'), // 정확한 선택자 사용
            historyTableBody: document.getElementById('history-body'),
            appTitle: document.getElementById('app-title'),
            imageTranslationCheckbox: document.getElementById('image-translation'),
            ocrGpuCheckbox: document.getElementById('ocr-gpu'),
            customModal: document.getElementById('custom-modal'),
            modalTitle: document.getElementById('modal-title'),
            modalMessage: document.getElementById('modal-message'),
            modalConfirmBtn: document.getElementById('modal-confirm-btn'),
            modalCancelBtn: document.getElementById('modal-cancel-btn')
        };

        // --- Logging Function ---
        function addLog(messageOrKey, isKey = false, type = 'info', interpolateParams = null) {
            if (!domElements.logBox) return;
            const logEntry = document.createElement('div');
            logEntry.classList.add(`log-entry-${type}`);
            let displayMessage = messageOrKey;
            if (isKey && i18nResources && i18nResources[messageOrKey]) {
                displayMessage = i18nResources[messageOrKey];
                if (interpolateParams) { for (const key in interpolateParams) { displayMessage = displayMessage.replace(new RegExp(`{${key}}`, 'g'), interpolateParams[key]); } }
            } else if (interpolateParams) { for (const key in interpolateParams) { displayMessage = displayMessage.replace(new RegExp(`{${key}}`, 'g'), interpolateParams[key]); } }
            const timestamp = new Date().toLocaleTimeString();
            logEntry.textContent = `[${timestamp}] ${displayMessage}`;
            domElements.logBox.appendChild(logEntry);
            domElements.logBox.scrollTop = domElements.logBox.scrollHeight;
        }

        function addDefaultNoModelsOption(customTextKey = 'no_models_found') {
            if (domElements.modelSelect) {
                domElements.modelSelect.innerHTML = '';
                const option = document.createElement('option');
                option.value = "";
                option.textContent = (i18nResources && i18nResources[customTextKey]) || customTextKey;
                domElements.modelSelect.appendChild(option);
                domElements.modelSelect.value = "";
            }
        }

        // --- Localization and UI Update Functions ---
        async function loadAndSetLanguageResources(langCode) {
            console.log(`[Localization] Attempting to load: ${langCode}`);
            try {
                const response = await fetch(`/api/ui_languages?lang=${langCode}`);
                if (!response.ok) {
                    const errorText = await response.text().catch(() => `HTTP ${response.status}`);
                    console.error(`[Localization] Failed to load language file: ${response.status}`, errorText);
                    throw new Error(`Failed to load language file: ${response.status}`);
                }
                const data = await response.json();
                i18nResources = data.resources || {};
                currentUILocale = data.current_language || langCode;
                localStorage.setItem('uiLanguagePDT', currentUILocale);
                document.documentElement.lang = currentUILocale.split('-')[0];
                console.log(`[Localization] Current language: ${currentUILocale}`);
                applyLocalization();
            } catch (error) {
                console.error('[Localization] Exception during language resource loading:', error);
                i18nResources = {};
                applyLocalization();
            }
        }

        function applyLocalization(elementScope = document) {
            console.log("[Localization] Applying localization...");
            elementScope.querySelectorAll('[data-i18n]').forEach(element => {
                const key = element.getAttribute('data-i18n');
                const fallbackText = element.dataset.i18nFallback || element.textContent || element.title || (element.placeholder || '');
                let localizedText = (i18nResources && i18nResources[key]) || fallbackText;

                const interpolateMatch = localizedText.match(/{[^{}]+}/g);
                if (interpolateMatch && element.dataset.i18nParams) {
                    try {
                        const params = JSON.parse(element.dataset.i18nParams);
                        for (const placeholder in params) {
                            localizedText = localizedText.replace(new RegExp(`{${placeholder}}`, 'g'), params[placeholder]);
                        }
                    } catch (e) { console.warn("Failed to parse i18n-params for key:", key, e); }
                }

                if (element.placeholder && (i18nResources && i18nResources[key])) { element.placeholder = localizedText; }
                else if (element.title && (i18nResources && i18nResources[key]) && !element.hasAttribute('data-i18n-tooltip')) { element.title = localizedText; }
                else if ((element.tagName === 'BUTTON' || element.tagName === 'SPAN' || element.tagName === 'LABEL' || element.tagName === 'H1' || element.tagName === 'H2' || element.tagName === 'H3' || element.tagName === 'TH' || element.tagName === 'P' || (element.tagName === 'OPTION' && element.value === "")) && (i18nResources && i18nResources[key])) { element.textContent = localizedText; }
                else if (element.tagName !== 'INPUT' && element.tagName !== 'SELECT' && (i18nResources && i18nResources[key])) { element.textContent = localizedText; }
            });
            elementScope.querySelectorAll('[data-i18n-tooltip]').forEach(element => {
                const key = element.getAttribute('data-i18n-tooltip');
                if (i18nResources && i18nResources[key]) { element.title = i18nResources[key]; }
            });

            if (elementScope === document) {
                if(domElements.appTitle) domElements.appTitle.textContent = (i18nResources && i18nResources.app_title) || 'Document Translator';
                updateTranslationLanguageOptions();
                updateOllamaStatusDisplay();
                updateMainButtonState(); // 버튼 상태 업데이트
                if (domElements.logBox && domElements.logBox.children.length === 1 && domElements.logBox.children[0].tagName === 'SPAN' && domElements.logBox.children[0].hasAttribute('data-i18n')) {
                    const key = domElements.logBox.children[0].getAttribute('data-i18n');
                    if (i18nResources && i18nResources[key]) { domElements.logBox.children[0].textContent = i18nResources[key]; }
                }
            }
            console.log("[Localization] Localization applied.");
        }

        function updateOllamaStatusDisplay(statusData = null) {
            if(!domElements.ollamaStatusText || !domElements.ollamaStatusLabel) return;
            domElements.ollamaStatusLabel.textContent = (i18nResources && i18nResources.status_label) || '상태';
            if (statusData) {
                const portText = (i18nResources && i18nResources.ollama_port_label) || '포트';
                 if (statusData.running) domElements.ollamaStatusText.textContent = `${(i18nResources && i18nResources.ollama_running) || '실행 중'} (${portText}: ${statusData.port})`;
                 else if (statusData.installed) domElements.ollamaStatusText.textContent = (i18nResources && i18nResources.ollama_installed_not_running) || '설치됨 (실행 안 됨)';
                 else domElements.ollamaStatusText.textContent = (i18nResources && i18nResources.ollama_not_installed) || '설치 안 됨';
            } else { domElements.ollamaStatusText.textContent = (i18nResources && i18nResources.status_checking) || '확인 중...'; }
        }

        function updateTranslationLanguageOptions() {
            console.log("[Localization] Updating translation language options...");
            const langOptionsMap = { "ko": "translation_lang_ko", "en": "translation_lang_en", "ja": "translation_lang_ja", "zh-CN": "translation_lang_zh_CN", "zh-TW": "translation_lang_zh_TW", "th": "translation_lang_th", "es": "translation_lang_es" };
            [domElements.sourceLangSelect, domElements.targetLangSelect].forEach(selectElement => {
                if (!selectElement) { console.warn("Language select dropdown not found for update."); return; }
                const currentSelectedValue = selectElement.value;
                selectElement.innerHTML = '';
                Object.keys(langOptionsMap).forEach(langCode => {
                    const option = document.createElement('option');
                    option.value = langCode;
                    option.textContent = (i18nResources && i18nResources[langOptionsMap[langCode]]) || langCode;
                    selectElement.appendChild(option);
                });
                if (currentSelectedValue && Array.from(selectElement.options).some(opt => opt.value === currentSelectedValue)) { selectElement.value = currentSelectedValue; }
                else if (selectElement.options.length > 0) {
                    if (selectElement.id === 'src-lang') { selectElement.value = (currentUILocale === 'ko' || currentUILocale === 'ja') ? currentUILocale : 'en'; }
                    else if (selectElement.id === 'tgt-lang') { selectElement.value = (currentUILocale === 'ko') ? 'en' : 'ko'; }
                }
            });
            console.log("[Localization] Translation language options updated.");
        }

        // --- Modal Functions ---
        function openModal(config) {
            if (!domElements.customModal || !domElements.modalTitle || !domElements.modalMessage || !domElements.modalConfirmBtn || !domElements.modalCancelBtn) {
                console.error("Modal elements not found! Falling back to native confirm.");
                const userConfirmed = confirm(config.messageText);
                if (userConfirmed) { if (config.onConfirm) config.onConfirm(); }
                else { if (config.onCancel) config.onCancel(); }
                return;
            }

            domElements.modalTitle.textContent = (i18nResources && i18nResources[config.titleKey]) || config.titleKey;
            domElements.modalTitle.dataset.i18n = config.titleKey;
            domElements.modalMessage.textContent = config.messageText;
            domElements.modalConfirmBtn.textContent = (i18nResources && i18nResources[config.confirmBtnKey]) || config.confirmBtnKey;
            domElements.modalConfirmBtn.dataset.i18n = config.confirmBtnKey;
            domElements.modalCancelBtn.textContent = (i18nResources && i18nResources[config.cancelBtnKey]) || config.cancelBtnKey;
            domElements.modalCancelBtn.dataset.i18n = config.cancelBtnKey;
            modalConfirmCallback = config.onConfirm;
            modalCancelCallback = config.onCancel;
            const modalThirdBtn = document.getElementById('modal-third-btn');
            if (config.thirdBtnKey && modalThirdBtn) {
                modalThirdBtn.textContent = (i18nResources && i18nResources[config.thirdBtnKey]) || config.thirdBtnKey;
                modalThirdBtn.dataset.i18n = config.thirdBtnKey;
                modalThirdOptionCallback = config.onThird;
                modalThirdBtn.style.display = 'inline-block';
            } else if (modalThirdBtn) {
                modalThirdBtn.style.display = 'none';
                modalThirdOptionCallback = null;
            }
            domElements.customModal.style.display = 'flex';
            setMainButtonState(APP_STATE.AWAITING_DOWNLOAD_CONFIRMATION);
        }

        function closeModal() {
            if (!domElements.customModal) return;
            domElements.customModal.style.display = 'none';
            modalConfirmCallback = null;
            modalCancelCallback = null;
            modalThirdOptionCallback = null;
        }


        // --- Core Application Logic ---
        function setMainButtonState(newState) {
            currentAppState = newState;
            if (newState === APP_STATE.COMPLETED_SUCCESS) {
                translatedFileAvailableButNotDownloaded = true;
            }
            updateMainButtonState();
        }

        function updateMainButtonState() {
            if (!domElements.startTranslateButton || !domElements.actionButton) {
                console.error("UI Error: Start or Action button not found in DOM.");
                return;
            }

            const fileReady = currentServerFilePath && currentFileObject;
            const sourceLangSelected = domElements.sourceLangSelect && domElements.sourceLangSelect.value;
            const targetLangSelected = domElements.targetLangSelect && domElements.targetLangSelect.value;
            const modelSelected = domElements.modelSelect && domElements.modelSelect.value;
            const ollamaRunning = domElements.ollamaStatusIndicator && domElements.ollamaStatusIndicator.classList.contains('status-online');

            domElements.startTranslateButton.style.display = 'inline-block';
            domElements.startTranslateButton.disabled = true;

            domElements.actionButton.style.display = 'none';
            domElements.actionButton.disabled = true;
            domElements.actionButton.classList.remove('stop-button', 'download-button');


            switch (currentAppState) {
                case APP_STATE.IDLE:
                    domElements.startTranslateButton.textContent = (i18nResources && i18nResources.start_translation_button) || "번역 시작";
                    if (fileReady && sourceLangSelected && targetLangSelected && modelSelected && ollamaRunning && !isModelInstallationInProgress) {
                        domElements.startTranslateButton.disabled = false;
                    }
                    domElements.actionButton.style.display = 'none';
                    break;

                case APP_STATE.TRANSLATING:
                    domElements.startTranslateButton.textContent = (i18nResources && i18nResources.start_translation_button) || "번역 시작";
                    domElements.startTranslateButton.disabled = true;

                    domElements.actionButton.style.display = 'inline-block';
                    domElements.actionButton.textContent = (i18nResources && i18nResources.stop_translation_button) || "번역 중지";
                    domElements.actionButton.classList.add('stop-button');
                    domElements.actionButton.disabled = false;
                    break;

                case APP_STATE.STOPPING:
                    domElements.startTranslateButton.textContent = (i18nResources && i18nResources.start_translation_button) || "번역 시작";
                    domElements.startTranslateButton.disabled = true;

                    domElements.actionButton.style.display = 'inline-block';
                    domElements.actionButton.textContent = (i18nResources && i18nResources.stopping_translation_button) || "중지 중...";
                    domElements.actionButton.disabled = true;
                    break;

                case APP_STATE.COMPLETED_SUCCESS:
                    domElements.startTranslateButton.textContent = (i18nResources && i18nResources.start_translation_button) || "번역 시작";
                    if (fileReady && sourceLangSelected && targetLangSelected && modelSelected && ollamaRunning && !isModelInstallationInProgress) {
                        domElements.startTranslateButton.disabled = false;
                    } else {
                        domElements.startTranslateButton.disabled = true;
                    }
                    translatedFileAvailableButNotDownloaded = true;
                    lastDownloadedTaskId = currentTranslationTaskId;

                    domElements.actionButton.style.display = 'inline-block';
                    domElements.actionButton.textContent = (i18nResources && i18nResources.download_translated_file_button) || "번역 파일 다운로드";
                    domElements.actionButton.classList.add('download-button');
                    domElements.actionButton.disabled = false;
                    break;

                case APP_STATE.DOWNLOAD_COMPLETED_CAN_OPEN_FOLDER:
                    domElements.startTranslateButton.textContent = (i18nResources && i18nResources.start_translation_button) || "번역 시작";
                     if (fileReady && sourceLangSelected && targetLangSelected && modelSelected && ollamaRunning && !isModelInstallationInProgress) {
                        domElements.startTranslateButton.disabled = false;
                    } else {
                        domElements.startTranslateButton.disabled = true;
                    }

                    domElements.actionButton.style.display = 'inline-block';
                    domElements.actionButton.textContent = (i18nResources && i18nResources.open_output_folder_button) || "결과 폴더 열기";
                    domElements.actionButton.disabled = false;
                    break;

                case APP_STATE.COMPLETED_ERROR:
                    domElements.startTranslateButton.textContent = (i18nResources && i18nResources.start_translation_button_retry) || "번역 재시도";
                    if (fileReady && sourceLangSelected && targetLangSelected && modelSelected && ollamaRunning && !isModelInstallationInProgress) {
                        domElements.startTranslateButton.disabled = false;
                    }
                    domElements.actionButton.style.display = 'none';
                    break;

                case APP_STATE.DOWNLOADING_MODEL:
                    domElements.startTranslateButton.textContent = (i18nResources && i18nResources.model_downloading_button) || "모델 다운로드 중...";
                    domElements.startTranslateButton.disabled = true;
                    domElements.actionButton.style.display = 'none';
                    break;

                case APP_STATE.AWAITING_DOWNLOAD_CONFIRMATION:
                    domElements.startTranslateButton.disabled = true;
                    domElements.actionButton.disabled = true;
                    if(domElements.actionButton.style.display !== 'none'){
                        // actionButton이 이미 표시되어 있었다면, 그대로 두고 disabled만 true
                    } else {
                        domElements.startTranslateButton.style.display = 'inline-block';
                    }
                    break;
                default:
                    domElements.startTranslateButton.textContent = (i18nResources && i18nResources.start_translation_button) || "번역 시작";
                    domElements.startTranslateButton.disabled = true;
                    domElements.actionButton.style.display = 'none';
                    break;
            }
        }

        async function checkOllamaStatus() {
            if (isModelInstallationInProgress) {
                console.log("Model installation in progress, skipping Ollama status check.");
                return;
            }
            console.log("Checking Ollama status...");
            domElements.ollamaManagementArea.innerHTML = '';

            try {
                const response = await fetch(`/api/check_ollama?lang=${currentUILocale}`);
                if (!response.ok) {
                    const errorText = await response.text().catch(() => `HTTP ${response.status}`);
                    if (domElements.ollamaStatusIndicator) {
                        domElements.ollamaStatusIndicator.classList.remove('status-online');
                        domElements.ollamaStatusIndicator.classList.add('status-offline');
                    }
                    const apiErrorMsgKey = 'ollama_status_error_api_generic';
                    if (domElements.ollamaStatusText) domElements.ollamaStatusText.textContent = ((i18nResources && i18nResources[apiErrorMsgKey]) || 'API 오류: ') + response.status;
                    addLog('log_ollama_status_api_error', true, 'error', { status: response.status, errorText: errorText });
                    throw new Error(`Ollama API response error: ${errorText}`);
                }
                const data = await response.json();
                console.log("Ollama status data received:", data);

                updateOllamaStatusDisplay(data);
                if (domElements.ollamaStatusIndicator) {
                    domElements.ollamaStatusIndicator.classList.toggle('status-online', data.running);
                    domElements.ollamaStatusIndicator.classList.toggle('status-offline', !data.running);
                }

                if (!data.installed) {
                    const notInstalledMsg = (i18nResources && i18nResources.ollama_not_installed_prompt) || 'Ollama가 설치되어 있지 않습니다. 공식 웹사이트에서 다운로드하여 설치해주세요.';
                    const downloadLinkText = (i18nResources && i18nResources.ollama_download_link_text) || 'Ollama 다운로드';
                    const downloadLink = `<a href="https://ollama.com/download" target="_blank" rel="noopener noreferrer">${downloadLinkText}</a>`;
                    domElements.ollamaManagementArea.innerHTML = `<p>${notInstalledMsg} ${downloadLink}</p>`;
                    addDefaultNoModelsOption('ollama_not_installed_no_models');
                } else if (!data.running) {
                    const notRunningMsg = (i18nResources && i18nResources.ollama_not_running_prompt) || 'Ollama가 설치되어 있지만 실행 중이 아닙니다.';
                    const startButtonEl = document.createElement('button'); // 변수명 변경 (domElements.startButton과 충돌 방지)
                    startButtonEl.id = 'start-ollama-btn';
                    startButtonEl.className = 'action-button';
                    startButtonEl.textContent = (i18nResources && i18nResources.ollama_start_button) || 'Ollama 시작';
                    startButtonEl.onclick = async () => {
                        startButtonEl.disabled = true;
                        startButtonEl.textContent = (i18nResources && i18nResources.ollama_starting_button) || '시작 중...';
                        addLog('log_ollama_attempt_start', true, 'info');
                        try {
                            const startResponse = await fetch('/api/start_ollama', { method: 'POST' });
                            const startData = await startResponse.json();
                            if (startData.success) {
                                addLog('log_ollama_start_success', true, 'success');
                                setTimeout(checkOllamaStatus, 3000);
                            } else {
                                addLog('log_ollama_start_failed', true, 'error', { error: startData.error || '알 수 없는 오류' });
                                startButtonEl.disabled = false;
                                startButtonEl.textContent = (i18nResources && i18nResources.ollama_start_button) || 'Ollama 시작';
                            }
                        } catch (e) {
                            addLog('log_ollama_start_exception', true, 'error', { message: e.message });
                            startButtonEl.disabled = false;
                            startButtonEl.textContent = (i18nResources && i18nResources.ollama_start_button) || 'Ollama 시작';
                        }
                    };
                    domElements.ollamaManagementArea.innerHTML = `<p>${notRunningMsg} </p>`;
                    domElements.ollamaManagementArea.appendChild(startButtonEl);
                    addDefaultNoModelsOption('ollama_not_running_no_models');
                } else {
                    populateModelDropdown(data.models);
                    const modelsArray = Array.isArray(data.models) ? data.models.map(m => (typeof m === 'string' ? m : m.name)).filter(name => name) : [];

                    if (!isModelInstallationInProgress && !modelsArray.includes(defaultOllamaModel)) {
                        const modelToInstall = defaultOllamaModel;
                        let message = ((i18nResources && i18nResources.status_default_model_missing_prompt) ||
                                       `기본 모델 '{modelName}'이(가) 설치되어 있지 않습니다. 최적의 번역 품질을 위해 설치를 권장합니다.`)
                                       .replace(/{modelName}/g, modelToInstall);
                        let installButtonText = ((i18nResources && i18nResources.button_install_default_model) ||
                                                 `{modelName} 설치`).replace(/{modelName}/g, modelToInstall);

                        const installPromptDiv = document.createElement('div');
                        installPromptDiv.style.marginTop = '5px';

                        const messageP = document.createElement('p');
                        messageP.textContent = message;
                        messageP.style.display = 'inline';

                        const installBtn = document.createElement('button');
                        installBtn.id = 'install-default-model-btn';
                        installBtn.className = 'action-button';
                        installBtn.style.marginLeft = '10px';
                        installBtn.textContent = installButtonText;

                        installBtn.onclick = async () => {
                            installBtn.disabled = true;
                            let installingText = ((i18nResources && i18nResources.button_installing_model) || "{modelName} 설치 중...")
                                                 .replace(/{modelName}/g, modelToInstall);
                            installBtn.textContent = installingText;
                            domElements.modelInstallMessage.textContent = installingText;
                            domElements.modelInstallationStatus.style.display = 'block';
                            domElements.modelInstallProgressBar.style.display = 'block';
                            domElements.modelInstallProgressFill.style.width = '0%';
                            domElements.modelInstallProgressFill.textContent = '0%';

                            await pullOllamaModel(modelToInstall);
                        };

                        installPromptDiv.appendChild(messageP);
                        installPromptDiv.appendChild(installBtn);
                        domElements.ollamaManagementArea.appendChild(installPromptDiv);

                    } else if (!isModelInstallationInProgress && modelsArray.includes(defaultOllamaModel)) {
                        if (currentAppState === APP_STATE.DOWNLOADING_MODEL) {
                            setMainButtonState(APP_STATE.IDLE);
                        }
                    }
                }
            } catch (error) {
                console.error("Exception during Ollama status check:", error);
                if (domElements.ollamaStatusIndicator) {
                    domElements.ollamaStatusIndicator.classList.remove('status-online');
                    domElements.ollamaStatusIndicator.classList.add('status-offline');
                }
                if (domElements.ollamaStatusText) domElements.ollamaStatusText.textContent = (i18nResources && i18nResources.ollama_status_exception) || '상태 확인 중 오류 발생';
                if (domElements.modelSelect) addDefaultNoModelsOption('model_load_error');
                if (currentAppState !== APP_STATE.AWAITING_DOWNLOAD_CONFIRMATION &&
                    currentAppState !== APP_STATE.TRANSLATING &&
                    currentAppState !== APP_STATE.DOWNLOADING_MODEL) {
                    setMainButtonState(APP_STATE.IDLE);
                }
            }
            updateMainButtonState();
        }

        async function pullOllamaModel(modelName) {
            addLog('log_model_pull_starting', true, 'info', { modelName: modelName });
            isModelInstallationInProgress = true;
            setMainButtonState(APP_STATE.DOWNLOADING_MODEL);
            let message = ((i18nResources && i18nResources.status_model_pulling) || "{modelName} 모델 다운로드 중...").replace('{modelName}', modelName);
            domElements.modelInstallMessage.textContent = message;
            domElements.modelInstallationStatus.style.display = 'block'; domElements.modelInstallProgressBar.style.display = 'block';
            domElements.modelInstallProgressFill.style.width = '0%'; domElements.modelInstallProgressFill.textContent = '0%';
            try {
                const pullResponse = await fetch('/api/pull_model', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ model_name: modelName, ui_language: currentUILocale }) });
                const pullData = await pullResponse.json();
                if (!pullResponse.ok || !pullData.success) { throw new Error(pullData.error || ((i18nResources && i18nResources.error_model_pull_start_failed) || '모델 다운로드 시작에 실패했습니다.'));}
                if (modelPullEventSource) { modelPullEventSource.close(); }
                modelPullEventSource = new EventSource(`/api/model_pull_progress/${encodeURIComponent(modelName)}?lang=${currentUILocale}`);
                modelPullEventSource.onmessage = function(event) {
                    const progressData = JSON.parse(event.data); console.log("Model pull progress:", progressData);
                    let statusMessage = progressData.status;
                    const statusKey = `model_pull_status_${progressData.status.toLowerCase().replace(/\s+/g, '_')}`;
                    if (i18nResources && i18nResources[statusKey]) { statusMessage = i18nResources[statusKey]; }
                    else if (progressData.status === "downloading" && progressData.total > 0 && progressData.completed >=0) {
                        statusMessage = ((i18nResources && i18nResources.model_pull_status_downloading_details) || "다운로드 중 ({completedMB}MB / {totalMB}MB)")
                            .replace("{completedMB}", (progressData.completed / 1024 / 1024).toFixed(1))
                            .replace("{totalMB}", (progressData.total / 1024 / 1024).toFixed(1));
                    }
                    domElements.modelInstallMessage.textContent = statusMessage;
                    if (progressData.total > 0 && progressData.completed >= 0) { const percentage = Math.round((progressData.completed / progressData.total) * 100); domElements.modelInstallProgressFill.style.width = `${percentage}%`; domElements.modelInstallProgressFill.textContent = `${percentage}%`; }
                    else if (progressData.status && (progressData.status.toLowerCase().includes("downloading") || progressData.status.toLowerCase().includes("pulling") || progressData.status.toLowerCase().includes("starting"))) { domElements.modelInstallProgressFill.style.width = '100%'; domElements.modelInstallProgressFill.textContent = ''; }
                    if (progressData.error) { addLog('log_model_pull_error', true, 'error', { modelName: modelName, details: progressData.error }); modelPullEventSource.close(); isModelInstallationInProgress = false; domElements.modelInstallationStatus.style.display = 'none'; setMainButtonState(APP_STATE.IDLE); checkOllamaStatus(); }
                    else if (progressData.done) { addLog('log_model_pull_success', true, 'success', { modelName: modelName }); modelPullEventSource.close(); isModelInstallationInProgress = false; domElements.modelInstallationStatus.style.display = 'none'; setMainButtonState(APP_STATE.IDLE); checkOllamaStatus(); }
                };
                modelPullEventSource.onerror = function(err) {
                    console.error("Model pull EventSource failed:", err); addLog('log_model_pull_error_connection', true, 'error', { modelName: modelName });
                    if (modelPullEventSource) modelPullEventSource.close(); isModelInstallationInProgress = false; domElements.modelInstallationStatus.style.display = 'none'; setMainButtonState(APP_STATE.IDLE); checkOllamaStatus();
                };
            } catch (error) {
                console.error("Error initiating model pull:", error); addLog('log_model_pull_init_failed', true, 'error', { modelName: modelName, message: error.message });
                isModelInstallationInProgress = false; domElements.modelInstallationStatus.style.display = 'none'; setMainButtonState(APP_STATE.IDLE); checkOllamaStatus();
            }
        }

        function populateModelDropdown(modelsDataFromApi) {
            if (domElements.modelSelect) {
                const currentModelVal = domElements.modelSelect.value; domElements.modelSelect.innerHTML = ''; let modelsArray = [];
                if (Array.isArray(modelsDataFromApi)) { modelsArray = modelsDataFromApi.map(model => (typeof model === 'string' ? model : (model && model.name))); }
                else if (modelsDataFromApi && typeof modelsDataFromApi === 'object' && Array.isArray(modelsDataFromApi.models)) { modelsArray = modelsDataFromApi.models.map(model => model.name); }
                modelsArray = modelsArray.filter(name => typeof name === 'string' && name.trim() !== '');
                if (modelsArray && modelsArray.length > 0) {
                    console.log(`[ModelPopulation] Populating with ${modelsArray.length} models:`, modelsArray);
                    modelsArray.forEach(modelName => { const option = document.createElement('option'); option.value = modelName; option.textContent = modelName; domElements.modelSelect.appendChild(option); });
                    if (modelsArray.includes(defaultOllamaModel)) { domElements.modelSelect.value = defaultOllamaModel; }
                    else if (currentModelVal && modelsArray.includes(currentModelVal)) { domElements.modelSelect.value = currentModelVal; }
                    else if (domElements.modelSelect.options.length > 0) { domElements.modelSelect.value = domElements.modelSelect.options[0].value; }
                    console.log(`[ModelPopulation] Model selection set to: ${domElements.modelSelect.value}`);
                } else { addDefaultNoModelsOption('no_models_found'); }
            } else { console.error("[ModelPopulation] CRITICAL: domElements.modelSelect not found!"); }
            updateMainButtonState();
        }

        function confirmAndProceedWithNewTask(actionCallback, revertAction = null) {
            if (translatedFileAvailableButNotDownloaded || currentAppState === APP_STATE.DOWNLOAD_COMPLETED_CAN_OPEN_FOLDER ) {
                let messageKey = 'modal_new_task_message';
                 if (currentAppState === APP_STATE.COMPLETED_SUCCESS){ // 다운로드 버튼이 보일 때
                    messageKey = 'modal_new_task_undownloaded_message';
                } else if (currentAppState === APP_STATE.DOWNLOAD_COMPLETED_CAN_OPEN_FOLDER) { // 폴더열기 버튼이 보일 때
                    messageKey = 'modal_new_task_after_download_message';
                }

                openModal({
                    titleKey: 'modal_new_task_title',
                    messageText: (i18nResources[messageKey] || "이전 작업에 대한 후속 조치가 필요합니다. 새 작업을 시작하시겠습니까?"),
                    confirmBtnKey: 'modal_button_yes_proceed',
                    cancelBtnKey: 'modal_button_no_cancel',
                    onConfirm: () => {
                        addLog('log_user_confirmed_new_task', true, 'info');
                        resetFileInput();
                        actionCallback();
                    },
                    onCancel: () => {
                        addLog('log_user_cancelled_new_task', true, 'info');
                        if (revertAction) { revertAction(); }
                        // 사용자가 취소했으므로, 이전 상태(버튼 모양 포함)를 유지해야 함.
                        // setMainButtonState(currentAppState); // 현재 상태를 다시 호출하여 UI를 이전 상태로 유지.
                        // 또는, updateMainButtonState()를 직접 호출할 수도 있음.
                        // 하지만, 모달이 닫힐 때 AWAITING_DOWNLOAD_CONFIRMATION 상태에서
                        // 이전 상태로 돌아가는 로직이 closeModal이나 모달 버튼 콜백에 명확히 있어야 함.
                        // 현재는 closeModal에서 특별한 상태 변경을 하지 않으므로,
                        // onCancel 콜백에서 이전 상태로 돌려주는 것이 안전.
                        // 예를 들어, 이전 상태가 COMPLETED_SUCCESS 였다면 해당 상태로.
                        // 이 부분은 좀 더 정교한 상태 관리가 필요할 수 있음.
                        // 지금은 revertAction() 후 updateMainButtonState()가 호출될 것을 기대.
                        if (currentAppState === APP_STATE.AWAITING_DOWNLOAD_CONFIRMATION) {
                            // 모달이 닫히면서 원래 상태로 돌아가야 함.
                            // translatedFileAvailableButNotDownloaded 플래그에 따라 상태 결정
                            if(translatedFileAvailableButNotDownloaded && lastDownloadedTaskId) { // 다운로드 안한 파일 있음
                                setMainButtonState(APP_STATE.COMPLETED_SUCCESS);
                            } else if (lastDownloadedTaskId) { // 다운로드는 했고 폴더 열기 가능 상태였음
                                setMainButtonState(APP_STATE.DOWNLOAD_COMPLETED_CAN_OPEN_FOLDER);
                            } else {
                                setMainButtonState(APP_STATE.IDLE);
                            }
                        }

                    }
                });
                return false;
            } else {
                if (currentAppState !== APP_STATE.IDLE &&
                    currentAppState !== APP_STATE.UPLOADING &&
                    currentAppState !== APP_STATE.ANALYZING &&
                    currentAppState !== APP_STATE.DOWNLOADING_MODEL
                    ) {
                    resetFileInput();
                }
                actionCallback();
                return true;
            }
        }

        async function handleFileSelect(file) {
            if (!file) return;

            const processFileSelectionActual = async () => {
                setMainButtonState(APP_STATE.UPLOADING);
                const allowedExtensions = ['.pptx', '.xlsx'];
                const fileExtension = `.${file.name.split('.').pop().toLowerCase()}`;
                if (!allowedExtensions.includes(fileExtension)) {
                    addLog('error_invalid_file_type_pptx', true, 'error'); resetFileInput(); return;
                }
                currentFileObject = file;
                currentOriginalFilePath = file.path; // [!INFO] 이 줄을 확인 또는 추가합니다.
                currentTaskTempOutputPath = null;
                if (domElements.fileNameDisplay) domElements.fileNameDisplay.textContent = file.name;
                if (domElements.fileUploadLabel) domElements.fileUploadLabel.textContent = file.name;
                addLog('file_analyzing', true, 'info');
                if (domElements.fileInfoBox) domElements.fileInfoBox.style.display = 'none';
                setMainButtonState(APP_STATE.ANALYZING);
                const formData = new FormData(); formData.append('file', currentFileObject);
                try {
                    const response = await fetch('/api/file_info', { method: 'POST', body: formData });
                    const data = await response.json();
                    if (response.ok && data.filepath) {
                        currentServerFilePath = data.filepath;
                        if (domElements.fileNameDisplay) domElements.fileNameDisplay.textContent = data.filename || currentFileObject.name;
                        if (domElements.slideCountDisplay) domElements.slideCountDisplay.textContent = data.info.slide_count ?? '-';
                        if (domElements.textCountDisplay) domElements.textCountDisplay.textContent = `${data.info.text_elements_count ?? '-'} (${data.info.total_text_char_count ?? '-'})`;
                        if (domElements.imageCountDisplay) domElements.imageCountDisplay.textContent = data.info.image_elements_count ?? '-';
                        if (domElements.chartCountDisplay) domElements.chartCountDisplay.textContent = data.info.chart_elements_count ?? '-';
                        if (domElements.fileInfoBox) domElements.fileInfoBox.style.display = 'block';
                        addLog('file_analysis_complete', true, 'success');
                        setMainButtonState(APP_STATE.IDLE);
                    } else { throw new Error(data.error || ((i18nResources && i18nResources.error_file_analysis_failed) || '파일 분석에 실패했습니다.')); }
                } catch (error) {
                    console.error("File processing error:", error); addLog('error_file_processing', true, 'error', { message: error.message });
                    resetFileInput();
                }
            };

            confirmAndProceedWithNewTask(processFileSelectionActual, () => {
                if (domElements.fileInput) { domElements.fileInput.value = ""; }
                if (domElements.fileUploadLabel) {
                   domElements.fileUploadLabel.textContent = (currentFileObject ? currentFileObject.name : ((i18nResources && i18nResources.file_upload_label) || '여기에 파워포인트 파일을 선택하거나 드래그 앤 드롭하세요'));
                }
            });
        }

        function resetFileInput() {
            currentFileObject = null; currentServerFilePath = null; currentTranslationTaskId = null;
            translatedFileAvailableButNotDownloaded = false;
            lastDownloadedTaskId = null;

            if (domElements.fileInput) domElements.fileInput.value = '';
            if (domElements.fileUploadLabel) domElements.fileUploadLabel.textContent = (i18nResources && i18nResources.file_upload_label) || '여기에 파워포인트 파일을 선택하거나 드래그 앤 드롭하세요';
            if (domElements.fileInfoBox) domElements.fileInfoBox.style.display = 'none';
            if (domElements.fileNameDisplay) domElements.fileNameDisplay.textContent = '-';
            if (domElements.slideCountDisplay) domElements.slideCountDisplay.textContent = '-';
            if (domElements.textCountDisplay) domElements.textCountDisplay.textContent = '-';
            if (domElements.imageCountDisplay) domElements.imageCountDisplay.textContent = '-';
            if (domElements.chartCountDisplay) domElements.chartCountDisplay.textContent = '-';
            if(domElements.progressPanel) domElements.progressPanel.style.display = 'none';
            if(domElements.progressFill) { domElements.progressFill.style.width = '0%'; domElements.progressFill.textContent = '0%'; }
            if(domElements.progressStatusDisplay) domElements.progressStatusDisplay.textContent = (i18nResources && i18nResources.status_preparing) || "준비 중...";

            setMainButtonState(APP_STATE.IDLE);
        }

        function startProgressMonitoring(taskId) {
            console.log(`[Progress] Monitoring started for task ID: ${taskId}`);
            if (progressEventSource) { progressEventSource.close(); }
            progressEventSource = new EventSource(`/api/progress/${taskId}?lang=${currentUILocale}`);
            progressEventSource.onmessage = function(event) {
                const data = JSON.parse(event.data);
                if (domElements.progressFill) { domElements.progressFill.style.width = `${data.progress}%`; domElements.progressFill.textContent = `${data.progress}%`; }
                let statusText = data.status;
                if (domElements.progressStatusDisplay) domElements.progressStatusDisplay.textContent = statusText;
                if (domElements.currentTaskDisplay) domElements.currentTaskDisplay.textContent = data.current_task || "";
                if (data.completed) {
                    if (data.temp_output_path) {
                        currentTaskTempOutputPath = data.temp_output_path;
                        console.log(`[Progress] Received temp output path: ${currentTaskTempOutputPath}`);
                    }
                    progressEventSource.close();
                    if (data.download_url && !data.error) {
                        setMainButtonState(APP_STATE.COMPLETED_SUCCESS);
                        addLog("translation_completed_download", true, "success");
                    } else if (data.error) {
                        addLog('log_translation_error_generic', true, "error", { error: data.error });
                        setMainButtonState(APP_STATE.COMPLETED_ERROR);
                    } else {
                         addLog("translation_completed_no_download", true, "info");
                         if (currentAppState !== APP_STATE.STOPPING && currentAppState !== APP_STATE.IDLE) { setMainButtonState(APP_STATE.COMPLETED_ERROR); }
                         else if (currentAppState === APP_STATE.STOPPING) { setMainButtonState(APP_STATE.IDLE); }
                    }
                }
            };
            progressEventSource.onerror = function(err) {
                console.error("EventSource failed:", err); addLog('error_progress_connection', true, "error");
                if (progressEventSource) progressEventSource.close(); setMainButtonState(APP_STATE.COMPLETED_ERROR);
            };
        }

        async function loadHistory() {
            if(!domElements.historyTableBody) { console.error("History table body not found."); addLog('error_history_area_not_found', true, 'error'); return; }
            try {
                console.log("Requesting history data...");
                const response = await fetch(`/api/history?lang=${currentUILocale}`);
                if (!response.ok) { const errorText = await response.text().catch(() => `HTTP ${response.status}`); addLog('error_history_load_status', true, 'error', { status: errorText }); console.error("History API request failed:", response.status, errorText); return; }
                const historyData = await response.json(); console.log("History data received:", historyData);
                domElements.historyTableBody.innerHTML = '';
                if (Array.isArray(historyData)) {
                    historyData.slice(0, 20).forEach(item => {
                        if (typeof item === 'object' && item !== null) {
                            const tr = document.createElement('tr');
                            tr.innerHTML = `<td>${item.name || '-'}</td> <td>${item.src || '-'}</td><td>${item.tgt || '-'}</td> <td>${item.model || '-'}</td><td>${item.status || item.status_key || '-'}</td> <td>${item.time || '-'}</td>`;
                            domElements.historyTableBody.appendChild(tr);
                        } else { console.warn("Invalid history item format:", item); }
                    });
                } else { console.warn("History data is not an array:", historyData); addLog('warning_history_invalid_format', true, 'warning');}
            } catch (error) { console.error("Exception loading history:", error); addLog('error_history_load_exception', true, 'error', { message: error.message }); }
        }

        const openLogFolderBtn = document.getElementById('openLogFolderBtn');
        if (openLogFolderBtn && window.electronAPI && window.electronAPI.openLogFolder) {
            openLogFolderBtn.addEventListener('click', async () => {
                try {
                    console.log('로그 폴더 열기 버튼 클릭됨');
                    const result = await window.electronAPI.openLogFolder();
                    if (result.success) {
                        console.log('로그 폴더 열기 성공:', result.path);
                        addLog('log_log_folder_opened', true, 'info', {path: result.path});
                    } else {
                        console.error('로그 폴더 열기 실패:', result.message);
                        addLog('log_log_folder_open_failed', true, 'error', {message: result.message});
                        alert(`로그 폴더를 열 수 없습니다: ${result.message}`);
                    }
                } catch (error) {
                    console.error('로그 폴더 열기 중 예외 발생:', error);
                    addLog('log_log_folder_open_exception', true, 'error', {message: error.message});
                    alert('로그 폴더를 여는 중 오류가 발생했습니다.');
                }
            });
        } else if (!openLogFolderBtn) {
            console.error("'openLogFolderBtn' ID를 가진 버튼을 찾을 수 없습니다.");
        } else if (!(window.electronAPI && window.electronAPI.openLogFolder)) {
            console.error("electronAPI.openLogFolder is not available. Check preload.js and contextBridge exposure.");
            if (openLogFolderBtn) openLogFolderBtn.disabled = true;
        }


        async function startActualTranslation() {
            if (!currentServerFilePath || !currentFileObject) {
                addLog('error_no_file_for_translation', true, 'error');
                return;
            }
            console.log('[Event] Starting actual translation process...');
            setMainButtonState(APP_STATE.TRANSLATING);

            if(domElements.progressPanel) domElements.progressPanel.style.display = 'block';
            if(domElements.progressFill) { domElements.progressFill.style.width = '0%'; domElements.progressFill.textContent = '0%'; }
            if(domElements.progressStatusDisplay) domElements.progressStatusDisplay.textContent = (i18nResources && i18nResources.status_translation_starting) || "번역 시작 중...";

            const payload = {
                filepath: currentServerFilePath,
                src_lang: domElements.sourceLangSelect.value,
                tgt_lang: domElements.targetLangSelect.value,
                model: domElements.modelSelect.value,
                image_translation: domElements.imageTranslationCheckbox.checked,
                ocr_temperature: parseFloat(domElements.ocrTemperatureSlider.value),
                ocr_use_gpu: domElements.ocrGpuCheckbox.checked,
                ui_language: currentUILocale,
                ooriginal_folder_path: currentOriginalFilePath
            };
            try {
                const response = await fetch('/api/translate', {
                    method: 'POST', headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                const data = await response.json();
                if (response.ok && data.task_id) {
                    currentTranslationTaskId = data.task_id;
                    addLog('log_translation_task_started_id', true, 'info', { taskId: currentTranslationTaskId });
                    startProgressMonitoring(currentTranslationTaskId);
                }
                else { throw new Error(data.error || ((i18nResources && i18nResources.error_translation_start_failed) || "번역 작업 시작에 실패했습니다.")); }
            } catch (error) {
                console.error("Error starting translation:", error);
                addLog('error_starting_translation_exception', true, 'error', { message: error.message });
                setMainButtonState(APP_STATE.COMPLETED_ERROR);
                if(domElements.progressPanel) domElements.progressPanel.style.display = 'none';
            }
        }

        // --- Event Listeners Setup ---
        function setupEventListeners() {
            if(domElements.uiLanguageSelect) { domElements.uiLanguageSelect.addEventListener('change', (e) => { console.log('[Event] UI language changed to:', e.target.value); loadAndSetLanguageResources(e.target.value); }); }
            if(domElements.swapLangButton && domElements.sourceLangSelect && domElements.targetLangSelect) {
                domElements.swapLangButton.addEventListener('click', () => {
                    console.log('[Event] Swap languages button clicked.');
                    const sourceVal = domElements.sourceLangSelect.value; const targetVal = domElements.targetLangSelect.value;
                    domElements.sourceLangSelect.value = targetVal; domElements.targetLangSelect.value = sourceVal;
                     updateMainButtonState();
                });
            }
            if (domElements.fileInput) {
                domElements.fileInput.addEventListener('change', (e) => {
                    if (e.target.files && e.target.files.length > 0) { handleFileSelect(e.target.files[0]); }
                    else { if (!currentFileObject) { if (domElements.fileUploadLabel) { domElements.fileUploadLabel.textContent = (i18nResources && i18nResources.file_upload_label) || '여기에 파워포인트 파일을 선택하거나 드래그 앤 드롭하세요'; } } }
                });
            }
             if (domElements.fileUploadLabel && domElements.fileInput) {
                ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => { domElements.fileUploadLabel.addEventListener(eventName, preventDefaults, false); document.body.addEventListener(eventName, preventDefaults, false); });
                function preventDefaults(e) { e.preventDefault(); e.stopPropagation(); }
                ['dragenter', 'dragover'].forEach(eventName => { domElements.fileUploadLabel.addEventListener(eventName, () => { domElements.fileUploadLabel.classList.add('dragover-active'); domElements.fileUploadLabel.textContent = (i18nResources && i18nResources.file_drop_prompt) || '파일을 여기에 드롭하세요'; }, false); });
                domElements.fileUploadLabel.addEventListener('dragleave', () => { domElements.fileUploadLabel.classList.remove('dragover-active'); const originalLabelKey = 'file_upload_label'; domElements.fileUploadLabel.textContent = currentFileObject ? currentFileObject.name : ((i18nResources && i18nResources[originalLabelKey]) || '여기에 파워포인트 파일을 선택하거나 드래그 앤 드롭하세요'); }, false);
                domElements.fileUploadLabel.addEventListener('drop', async (e) => {
                    domElements.fileUploadLabel.classList.remove('dragover-active'); const droppedFiles = e.dataTransfer.files;
                    if (droppedFiles.length > 0) { handleFileSelect(droppedFiles[0]); }
                    else { const originalLabelKey = 'file_upload_label'; domElements.fileUploadLabel.textContent = (i18nResources && i18nResources[originalLabelKey]) || '여기에 파워포인트 파일을 선택하거나 드래그 앤 드롭하세요'; }
                }, false);
            }
            [domElements.sourceLangSelect, domElements.targetLangSelect, domElements.modelSelect].forEach(selectElement => {
                if (selectElement) {
                    let previousValue = selectElement.value;
                    selectElement.addEventListener('focus', () => { previousValue = selectElement.value; });
                    selectElement.addEventListener('change', (event) => {
                        const applyChange = () => {
                            previousValue = selectElement.value;
                            updateMainButtonState();
                        };
                        const revertChange = () => {
                            event.target.value = previousValue;
                            updateMainButtonState();
                        };
                        confirmAndProceedWithNewTask(applyChange, revertChange);
                    });
                }
            });
            if(domElements.ocrTemperatureSlider && domElements.ocrTemperatureValueDisplay) { domElements.ocrTemperatureSlider.addEventListener('input', (e) => { domElements.ocrTemperatureValueDisplay.textContent = e.target.value; });}

            if(domElements.startTranslateButton) {
                domElements.startTranslateButton.addEventListener('click', async () => {
                    if (currentAppState === APP_STATE.IDLE || currentAppState === APP_STATE.COMPLETED_ERROR) {
                        const selectedModel = domElements.modelSelect.value;
                        const availableModels = Array.from(domElements.modelSelect.options).map(opt => opt.value).filter(val => val !== "");
                        const isDefaultModelAvailable = availableModels.includes(defaultOllamaModel);

                        if (!isDefaultModelAvailable && selectedModel && selectedModel !== defaultOllamaModel && availableModels.length > 0) {
                            addLog('log_gemma_recommendation_shown', true, 'info', {defaultModelName: defaultOllamaModel});
                            let message = (i18nResources.modal_recommend_gemma_message ||
                                           "선택하신 모델({selectedModel})로 번역이 가능하지만, 최적의 품질을 위해 '{defaultModelName}' 모델 사용을 권장합니다. 현재 설치되어 있지 않습니다. 지금 '{defaultModelName}' 모델을 다운로드하시겠습니까?")
                                           .replace(/{defaultModelName}/g, defaultOllamaModel)
                                           .replace(/{selectedModel}/g, selectedModel);
                            openModal({
                                titleKey: 'modal_recommend_gemma_title',
                                messageText: message,
                                confirmBtnKey: 'modal_button_download_gemma',
                                cancelBtnKey: 'modal_button_proceed_anyway',
                                onConfirm: () => {
                                    addLog('log_user_chose_to_download_gemma', true, 'info', {defaultModelName: defaultOllamaModel});
                                    pullOllamaModel(defaultOllamaModel);
                                },
                                onCancel: () => {
                                    addLog('log_user_proceeded_without_gemma', true, 'info', { selectedModel: selectedModel });
                                    startActualTranslation();
                                }
                            });
                        } else {
                            startActualTranslation();
                        }
                    } else {
                         console.log(`[Event] 시작 번역 버튼 클릭 무시됨 (현재 상태: ${currentAppState})`);
                    }
                });
            }

            if(domElements.actionButton) {
                domElements.actionButton.addEventListener('click', async () => {
                    switch (currentAppState) {
                        case APP_STATE.TRANSLATING:
                            console.log(`[Event] 액션 버튼 클릭: 작업 ${currentTranslationTaskId}에 대한 번역 중지`);
                            if (currentTranslationTaskId) {
                                setMainButtonState(APP_STATE.STOPPING);
                                addLog('translation_stopping_task', true, 'info', { taskId: currentTranslationTaskId });
                                try {
                                    const response = await fetch(`/api/stop_translation/${currentTranslationTaskId}`, { method: 'POST' });
                                    const data = await response.json();
                                    if (response.ok) {
                                        addLog('log_translation_stop_signal_sent', true, 'success');
                                    } else {
                                        throw new Error(data.error || ((i18nResources && i18nResources.error_sending_stop_signal) || "중지 신호 전송에 실패했습니다."));
                                    }
                                } catch (error) {
                                    console.error("Error stopping translation:", error);
                                    addLog('error_stopping_translation_exception', true, 'error', { message: error.message });
                                    setMainButtonState(APP_STATE.TRANSLATING);
                                }
                            } else {
                                addLog('warning_no_active_task_to_stop', true, 'warning');
                                setMainButtonState(APP_STATE.IDLE);
                            }
                            break;

                        case APP_STATE.COMPLETED_SUCCESS:
                            console.log(`[Event] Action button clicked: Save file for task ${currentTranslationTaskId}`);

                            // [!INFO] --- 최종 다운로드 로직 ---
                            // 원본 파일 경로와, 서버에 임시 저장된 결과물 경로가 모두 있는지 확인
                            if (currentOriginalFilePath && currentTaskTempOutputPath) {

                                console.log(`[Save] Requesting main process to save. Temp: ${currentTaskTempOutputPath}, Original: ${currentOriginalFilePath}`);
                                const result = await window.electronAPI.saveTranslatedFile({
                                    tempFilePath: currentTaskTempOutputPath,
                                    originalPath: currentOriginalFilePath,
                                    targetLang: domElements.targetLangSelect.value // 이 줄을 추가하세요
                                });

                                if (result && result.success) {
                                    addLog(`파일이 성공적으로 저장되었습니다: ${result.path}`, false, 'success');
                                    setMainButtonState(APP_STATE.DOWNLOAD_COMPLETED_CAN_OPEN_FOLDER);
                                } else {
                                    addLog(result.message || '파일 저장이 취소되었거나 실패했습니다.', false, 'warning');
                                }

                            } else {
                                // 이 오류는 정상적인 상황에서는 발생하지 않아야 합니다.
                                addLog('파일 저장 실패: 원본 또는 결과물 경로를 찾을 수 없습니다.', true, 'error');
                                console.error(`Save failed. OriginalPath: ${currentOriginalFilePath}, TempOutputPath: ${currentTaskTempOutputPath}`);
                                setMainButtonState(APP_STATE.COMPLETED_ERROR);
                            }
                            break;
                        case APP_STATE.DOWNLOAD_COMPLETED_CAN_OPEN_FOLDER:
                            console.log(`[Event] 액션 버튼 클릭: 결과 폴더 열기`);
                            try {
                                if (window.electronAPI && window.electronAPI.openOutputFolder) {
                                    const result = await window.electronAPI.openOutputFolder();
                                    if (result.success) {
                                        addLog('log_output_folder_opened', true, 'info', { path: result.path });
                                    } else {
                                        addLog('log_output_folder_open_failed', true, 'error', { message: result.message });
                                        alert(`결과 폴더를 여는 데 실패했습니다: ${result.message}`);
                                    }
                                } else {
                                    addLog('log_electron_api_not_found_open_folder', true, 'error');
                                    alert('폴더를 열 수 없습니다: API를 사용할 수 없습니다.');
                                }
                            } catch (error) {
                                addLog('log_output_folder_open_exception', true, 'error', { message: error.message });
                                alert('결과 폴더를 여는 중 오류가 발생했습니다.');
                            }
                            break;
                        // --- 추가 끝 ---

                        default:
                            console.log(`[Event] 액션 버튼이 처리되지 않은 상태에서 클릭됨: ${currentAppState}`);
                            break;
                    }
                });
            }

            if(domElements.tabs && domElements.tabContents) {
                domElements.tabs.forEach(tab => {
                    tab.addEventListener('click', () => {
                        const tabName = tab.dataset.tab; console.log('[Event] Tab clicked:', tabName);
                        domElements.tabs.forEach(t => t.classList.remove('active')); tab.classList.add('active');
                        domElements.tabContents.forEach(content => content.classList.remove('active'));
                        const activeContent = document.getElementById(`${tabName}-tab`);
                        if (activeContent) { activeContent.classList.add('active'); console.log(`Tab content ${activeContent.id} activated.`); }
                        else { console.error(`Tab content with ID '${tabName}-tab' not found.`); }
                        if (tabName === 'history') { console.log('History tab activated, loading history...'); loadHistory(); }
                    });
                });
            } else { console.error("Tabs or tab contents not found; tab switching logic cannot be set up."); }

            if (domElements.modalConfirmBtn) {
                domElements.modalConfirmBtn.addEventListener('click', () => {
                    if (modalConfirmCallback) { modalConfirmCallback(); }
                    closeModal();
                });
            }
            if (domElements.modalCancelBtn) {
                domElements.modalCancelBtn.addEventListener('click', () => {
                    if (modalCancelCallback) { modalCancelCallback(); }
                    closeModal();
                     // 모달 취소 시, AWAITING_DOWNLOAD_CONFIRMATION 상태였다면 이전 상태로 돌려야 함
                    if (currentAppState === APP_STATE.AWAITING_DOWNLOAD_CONFIRMATION) {
                        if (translatedFileAvailableButNotDownloaded && lastDownloadedTaskId) {
                            setMainButtonState(APP_STATE.COMPLETED_SUCCESS);
                        } else if (lastDownloadedTaskId) { // 다운로드는 했고 폴더 열기 가능 상태였음
                            setMainButtonState(APP_STATE.DOWNLOAD_COMPLETED_CAN_OPEN_FOLDER);
                        } else {
                            setMainButtonState(APP_STATE.IDLE);
                        }
                    }
                });
            }
            const modalThirdBtn = document.getElementById('modal-third-btn');
            if (modalThirdBtn) {
                modalThirdBtn.addEventListener('click', () => {
                    if (modalThirdOptionCallback) { modalThirdOptionCallback(); }
                    closeModal();
                });
            }
            if (domElements.customModal) {
                domElements.customModal.addEventListener('click', (event) => {
                    if (event.target === domElements.customModal) {
                        if (modalCancelCallback) { // 오버레이 클릭 시 취소 콜백 실행
                             modalCancelCallback();
                        }
                        closeModal();
                        if (currentAppState === APP_STATE.AWAITING_DOWNLOAD_CONFIRMATION) {
                             if (translatedFileAvailableButNotDownloaded && lastDownloadedTaskId) {
                                setMainButtonState(APP_STATE.COMPLETED_SUCCESS);
                            } else if (lastDownloadedTaskId) {
                                setMainButtonState(APP_STATE.DOWNLOAD_COMPLETED_CAN_OPEN_FOLDER);
                            } else {
                                setMainButtonState(APP_STATE.IDLE);
                            }
                        }
                    }
                });
            }
        }

        // --- Initialization ---
        window.addEventListener('load', async () => {
            console.log("Page loaded, starting initialization.");

            translatedFileAvailableButNotDownloaded = false;
            const uiLanguageOptions = { "ko": "한국어", "en": "English", "ja": "日本語", "zh-CN": "简体中文", "zh-TW": "繁體中文", "th": "ไทย" };
            if(domElements.uiLanguageSelect) {
                Object.entries(uiLanguageOptions).forEach(([code, name]) => { const option = document.createElement('option'); option.value = code; option.textContent = name; domElements.uiLanguageSelect.appendChild(option); });
                const savedLanguage = localStorage.getItem('uiLanguagePDT') || 'ko';
                domElements.uiLanguageSelect.value = savedLanguage;
                await loadAndSetLanguageResources(savedLanguage);
            } else { console.warn("UI language select dropdown not found. Defaulting to 'ko'."); await loadAndSetLanguageResources('ko'); }
            setupEventListeners();
            await checkOllamaStatus();
            loadHistory();
            resetFileInput();
            console.log("Initialization complete.");
        });
    </script>
</body>
</html>